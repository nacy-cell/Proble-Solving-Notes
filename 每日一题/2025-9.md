# 每日一题-2025年9月

## 9.13 3541.找到频率最高的元音和辅音(简单)

### 题目描述

难度：简单 1239

>给你一个由小写英文字母（'a' 到 'z'）组成的字符串 s。你的任务是找出出现频率**最高**的元音（'a'、'e'、'i'、'o'、'u' 中的一个）和出现频率**最高**的辅音（除元音以外的所有字母），并返回这两个频率之和。
**注意**：如果有多个元音或辅音具有相同的最高频率，可以任选其中一个。如果字符串中没有元音或没有辅音，则其频率视为 0。
一个字母 x 的**频率**是它在字符串中出现的次数。

提示:
>1 <= s.length <= 100
s 只包含小写英文字母

### 思路解析

一次遍历，统计每一个字母的出现次数
分开统计元音和辅音出现次数最高的字母，求和即可

### 代码

```cpp
int maxFreqSum(std::string s) {
        int times[27] = {0};
        for (char c : s) {
            times[c - 'a']++;
        }
        int ans1 = 0,ans2=0;
        for (int i = 0; i < 27; i++) {
            if (i==0 || i==4 || i==8 || i==14 || i==20) {
                ans1=std::max(ans1,times[i]);
            } else {
                ans2=std::max(ans2,times[i]);
            }
        }
        return ans1+ans2;
    }
```

## 9.14 966.元音拼写检查器（中等）

### 题目描述

难度：中等（1795）

>在给定单词列表 wordlist 的情况下，我们希望实现一个拼写检查器，将查询单词转换为正确的单词。
对于给定的查询单词 query，拼写检查器将会处理两类拼写错误：
**大小写**：如果查询匹配单词列表中的某个单词（**不区分大小写**），则返回的正确单词与单词列表中的大小写相同。
例如：```wordlist = ["yellow"], query = "YellOw": correct = "yellow"```
例如：```wordlist = ["Yellow"], query = "yellow": correct = "Yellow"```
例如：```wordlist = ["yellow"], query = "yellow": correct = "yellow"```
**元音错误**：如果在将查询单词中的元音 ('a', 'e', 'i', 'o', 'u')  分别替换为任何元音后，能与单词列表中的单词匹配（**不区分大小写**），则返回的正确单词与单词列表中的匹配项大小写相同。
例如：```wordlist = ["YellOw"], query = "yollow": correct = "YellOw"```
例如：```wordlist = ["YellOw"], query = "yeellow": correct = ""``` （无匹配项）
例如：```wordlist = ["YellOw"], query = "yllw": correct = ""``` （无匹配项）
此外，拼写检查器还按照以下优先级规则操作：
1.当查询完全匹配单词列表中的某个单词（**区分大小写**）时，应返回相同的单词。
2.当查询匹配到大小写问题的单词时，您应该返回单词列表中的第一个这样的匹配项。
3.当查询匹配到元音错误的单词时，您应该返回单词列表中的第一个这样的匹配项。
4.如果该查询在单词列表中没有匹配项，则应返回空字符串。
给出一些查询 queries，返回一个单词列表 answer，其中 answer[i] 是由查询 query = queries[i] 得到的正确单词。

提示：
>1 <= wordlist.length, queries.length <= 5000
1 <= wordlist[i].length, queries[i].length <= 7
wordlist[i] 和 queries[i] 只包含英文字母

### 思路解析

1. 先将wordlist里的单词存入set中（方便查询）
2. 将wordlist中单词转换成小写，存入lower_map中(先检查是否存在，确保只存入第一个)，进行lower_case到原单词的映射。
3. 将lower_case单词中所有的元音字母替换成'a',去除元音字母的差异,并存入vowels_map,实现vowels_ignored_case到原单词的映射
4. 最后遍历querys集合进行查询，查询每一个单词对应的原单词即可

### 代码

```cpp
class Solution_25_9_14 {
public:

    string to_lower(string s)const {
        for (char&c:s) {
            c=tolower(c);
        }
        return s;
    }

    string replace(string s) {
        for (char&c:s) {
            if (c=='e'||c=='i'||c=='o'||c=='u')
                c='a';
        }
        return s;
    }

    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {
        unordered_set wordset(wordlist.begin(), wordlist.end());
        unordered_map<string,string>lower_map;
        unordered_map<string,string>vowels_map;
        for (string& word:wordlist) {
            //大小写匹配
            string lower = to_lower(word);
            if (!lower_map.count(lower)) {
                lower_map[lower] = word;
            }
            //原因匹配
            string vowels=replace(lower);
            if (!vowels_map.count(vowels)) {
                vowels_map[vowels] = word;
            }
        }


        vector<string> result;
        for (string& word:queries) {
            string lower = to_lower(word);
            string vowels=replace(lower);

            if (wordset.count(word))
                result.push_back(word);
            else if (lower_map.count(lower))
                result.push_back(lower_map[lower]);
            else if (vowels_map.count(vowels))
                result.push_back(vowels_map[vowels]);
            else result.emplace_back("");
        }

        return result;
    }
};
```

## 9.15 1935.可以输入的最大单词数(简单)

### 题目描述

难度： 简单（1227）
>键盘出现了一些故障，有些字母键无法正常工作。而键盘上所有其他键都能够正常工作。
给你一个由若干单词组成的字符串 `text` ，单词间由单个空格组成（不含前导和尾随空格）；另有一个字符串 `brokenLetters` ，由所有已损坏的不同字母键组成，返回你可以使用此键盘完全输入的 `text`中单词的数目。

提示：
>1 <= text.length <= 104
0 <= brokenLetters.length <= 26
text 由若干用单个空格分隔的单词组成，且不含任何前导和尾随空格
每个单词仅由小写英文字母组成
brokenLetters 由 互不相同 的小写英文字母组成

### 思路解析

1. 首先把故障键位存入set中，方便查询
2. 使用flag标志位标记当前单词是否存在故障位
3. text后面加一个" "方便处理
4. 遍历text所有字母，检查该字母是否是故障字母，如果是把flag置为false;当遇到" "说明一个单词扫描结束:如果flag=true,++ans;否则重新把flag置于true进行下一个单词的扫描
5. 最后返回ans即可

### 代码

```cpp
int canBeTypedWords(string text, string brokenLetters) {

        unordered_set<char> unenble_set;
        for (char letter : brokenLetters) {
            unenble_set.insert(letter);
        }

        int ans=0;
        text=text+" ";
        bool flag=true;
        
        for (char letter : text) {
            if (letter==' ') {
                if (flag) ++ans;
                flag=true;
            }
            else if (unenble_set.find(letter)!=unenble_set.end()) {
                flag=false;
            }
        }
        return ans;
    }
```