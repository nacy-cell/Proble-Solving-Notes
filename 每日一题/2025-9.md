# 每日一题-2025年9月

## 9.13 3541.找到频率最高的元音和辅音(简单)

### 题目描述

难度：简单 1239

>给你一个由小写英文字母（'a' 到 'z'）组成的字符串 s。你的任务是找出出现频率**最高**的元音（'a'、'e'、'i'、'o'、'u' 中的一个）和出现频率**最高**的辅音（除元音以外的所有字母），并返回这两个频率之和。
**注意**：如果有多个元音或辅音具有相同的最高频率，可以任选其中一个。如果字符串中没有元音或没有辅音，则其频率视为 0。
一个字母 x 的**频率**是它在字符串中出现的次数。

提示:
>1 <= s.length <= 100
s 只包含小写英文字母

### 思路解析

一次遍历，统计每一个字母的出现次数
分开统计元音和辅音出现次数最高的字母，求和即可

### 代码

```cpp
int maxFreqSum(std::string s) {
        int times[27] = {0};
        for (char c : s) {
            times[c - 'a']++;
        }
        int ans1 = 0,ans2=0;
        for (int i = 0; i < 27; i++) {
            if (i==0 || i==4 || i==8 || i==14 || i==20) {
                ans1=std::max(ans1,times[i]);
            } else {
                ans2=std::max(ans2,times[i]);
            }
        }
        return ans1+ans2;
    }
```

## 9.14 966.元音拼写检查器（中等）

### 题目描述

难度：中等（1795）

>在给定单词列表 wordlist 的情况下，我们希望实现一个拼写检查器，将查询单词转换为正确的单词。
对于给定的查询单词 query，拼写检查器将会处理两类拼写错误：
**大小写**：如果查询匹配单词列表中的某个单词（**不区分大小写**），则返回的正确单词与单词列表中的大小写相同。
例如：```wordlist = ["yellow"], query = "YellOw": correct = "yellow"```
例如：```wordlist = ["Yellow"], query = "yellow": correct = "Yellow"```
例如：```wordlist = ["yellow"], query = "yellow": correct = "yellow"```
**元音错误**：如果在将查询单词中的元音 ('a', 'e', 'i', 'o', 'u')  分别替换为任何元音后，能与单词列表中的单词匹配（**不区分大小写**），则返回的正确单词与单词列表中的匹配项大小写相同。
例如：```wordlist = ["YellOw"], query = "yollow": correct = "YellOw"```
例如：```wordlist = ["YellOw"], query = "yeellow": correct = ""``` （无匹配项）
例如：```wordlist = ["YellOw"], query = "yllw": correct = ""``` （无匹配项）
此外，拼写检查器还按照以下优先级规则操作：
1.当查询完全匹配单词列表中的某个单词（**区分大小写**）时，应返回相同的单词。
2.当查询匹配到大小写问题的单词时，您应该返回单词列表中的第一个这样的匹配项。
3.当查询匹配到元音错误的单词时，您应该返回单词列表中的第一个这样的匹配项。
4.如果该查询在单词列表中没有匹配项，则应返回空字符串。
给出一些查询 queries，返回一个单词列表 answer，其中 answer[i] 是由查询 query = queries[i] 得到的正确单词。

提示：
>1 <= wordlist.length, queries.length <= 5000
1 <= wordlist[i].length, queries[i].length <= 7
wordlist[i] 和 queries[i] 只包含英文字母

### 思路解析

1. 先将wordlist里的单词存入set中（方便查询）
2. 将wordlist中单词转换成小写，存入lower_map中(先检查是否存在，确保只存入第一个)，进行lower_case到原单词的映射。
3. 将lower_case单词中所有的元音字母替换成'a',去除元音字母的差异,并存入vowels_map,实现vowels_ignored_case到原单词的映射
4. 最后遍历querys集合进行查询，查询每一个单词对应的原单词即可

### 代码

```cpp
class Solution_25_9_14 {
public:

    string to_lower(string s)const {
        for (char&c:s) {
            c=tolower(c);
        }
        return s;
    }

    string replace(string s) {
        for (char&c:s) {
            if (c=='e'||c=='i'||c=='o'||c=='u')
                c='a';
        }
        return s;
    }

    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {
        unordered_set wordset(wordlist.begin(), wordlist.end());
        unordered_map<string,string>lower_map;
        unordered_map<string,string>vowels_map;
        for (string& word:wordlist) {
            //大小写匹配
            string lower = to_lower(word);
            if (!lower_map.count(lower)) {
                lower_map[lower] = word;
            }
            //原因匹配
            string vowels=replace(lower);
            if (!vowels_map.count(vowels)) {
                vowels_map[vowels] = word;
            }
        }


        vector<string> result;
        for (string& word:queries) {
            string lower = to_lower(word);
            string vowels=replace(lower);

            if (wordset.count(word))
                result.push_back(word);
            else if (lower_map.count(lower))
                result.push_back(lower_map[lower]);
            else if (vowels_map.count(vowels))
                result.push_back(vowels_map[vowels]);
            else result.emplace_back("");
        }

        return result;
    }
};
```

## 9.15 1935.可以输入的最大单词数(简单)

### 题目描述

难度： 简单（1227）
>键盘出现了一些故障，有些字母键无法正常工作。而键盘上所有其他键都能够正常工作。
给你一个由若干单词组成的字符串 `text` ，单词间由单个空格组成（不含前导和尾随空格）；另有一个字符串 `brokenLetters` ，由所有已损坏的不同字母键组成，返回你可以使用此键盘完全输入的 `text`中单词的数目。

提示：
>1 <= text.length <= 104
0 <= brokenLetters.length <= 26
text 由若干用单个空格分隔的单词组成，且不含任何前导和尾随空格
每个单词仅由小写英文字母组成
brokenLetters 由 互不相同 的小写英文字母组成

### 思路解析

1. 首先把故障键位存入set中，方便查询
2. 使用flag标志位标记当前单词是否存在故障位
3. text后面加一个" "方便处理
4. 遍历text所有字母，检查该字母是否是故障字母，如果是把flag置为false;当遇到" "说明一个单词扫描结束:如果flag=true,++ans;否则重新把flag置于true进行下一个单词的扫描
5. 最后返回ans即可

### 代码

```cpp
int canBeTypedWords(string text, string brokenLetters) {

        unordered_set<char> unenble_set;
        for (char letter : brokenLetters) {
            unenble_set.insert(letter);
        }

        int ans=0;
        text=text+" ";
        bool flag=true;
        
        for (char letter : text) {
            if (letter==' ') {
                if (flag) ++ans;
                flag=true;
            }
            else if (unenble_set.find(letter)!=unenble_set.end()) {
                flag=false;
            }
        }
        return ans;
    }
```

## 9.16 2197.替换数组中的非互质数(困难)

### 题目描述

难度：困难（2057） 实际难度简单题
>给你一个整数数组 nums 。请你对数组执行下述操作：
从 nums 中找出 任意 两个 **相邻** 的 **非互质** 数。
如果不存在这样的数，终止 这一过程。
否则，删除这两个数，并 **替换** 为它们的 **最小公倍数**（Least Common Multiple，LCM）。
只要还能找出两个相邻的非互质数就继续 重复 这一过程。
返回修改后得到的 最终 数组。可以证明的是，以 **任意** 顺序替换相邻的非互质数都可以得到相同的结果。
生成的测试用例可以保证最终数组中的值 小于或者等于 108 。
两个数字 x 和 y 满足 **非互质数** 的条件是：GCD(x, y) > 1 ，其中 GCD(x, y) 是 x 和 y 的 最大公约数 。

提示：
>1 <= nums.length <= 105
1 <= nums[i] <= 105
生成的测试用例可以保证最终数组中的值 小于或者等于 108 。

### 思路解析

最大公因数可以通过欧几里德算法或gcd(a,b)(cpp17 numeric)函数获得
a,b的最小公倍数是a*b/gcd(a,b)先除后乘避免数据溢出
实际数据结构是栈，为了方便使用vector函数

1. 遍历数组，如果当前数字与栈顶数字不互质，计算最小公倍数
2. 将最小公倍数视为当前数字，继续与栈顶比较，直到互质或栈空，当前数字入栈。即可维护相邻数字互质。
3. 返回得到的栈即可

### 代码

```cpp
    int get_gcd(int a, int b) {
        if (b == 0)
            return a;
        return get_gcd(b, a % b);
    }

    vector<int> replaceNonCoprimes(vector<int>& nums) {
        vector<int> st;
        for (auto num : nums) {
            while (!st.empty()) {
                int gcd = get_gcd(st.back(), num);
                if (gcd == 1) {
                    break;
                }
                num = num/gcd*st.back();
                st.pop_back();
            }
            st.push_back(num);
        }
        return st;
    }
```

## 9.17 2349.设计数字容器系统(中等)

### 题目描述

难度： 中等(1540)

>设计一个数字容器系统，可以实现以下功能：
在系统中给定下标处 **插入** 或者 **替换** 一个数字。
**返回** 系统中给定数字的最小下标。
请你实现一个 `NumberContainers` 类：
`NumberContainers()` 初始化数字容器系统。
`void change(int index, int number)` 在下标 `index` 处填入 number 。如果该下标 index 处已经有数字了，那么用 `number` 替换该数字。
`int find(int number)` 返回给定数字 `number` 在系统中的最小下标。如果系统中没有 `number` ，那么返回`-1` 。

提示：
>1 <= index, number <= 10^9^
调用 change 和 find 的 **总次数** 不超过 10^5^ 次。

### 思路解析

#### 1.哈希表+set

使用
`unordered_map<int, int> index_to_number;` `unordered_map<int, set<int>> number_to_index`来存储索引到数字和数字到索引的映射

1. change函数：
   先去删除index对应的原`number`的索引映射集对index的映射
   然后添加index->number的映射，之后把index添加到number的映射集中，set会自动排序确保头部是`find`要求的最小下标
2. find函数：直接从`number_to_index`查找即可（注意判空）

#### 2.哈希表+懒删除堆

使用`unordered_map<int, int> index_to_number` `unordered_map<int, priority_queue<int, vector<int>, greater<int>>> number_to_indices`来存储索引到数字和数字到索引的映射
greater确保从小到达排序

1. change函数： 直接插入双映射即可（重合的index_to_numer会自动替换）
2. find函数，首先获取number对应的映射集合。从小到大遍历nuber的映射集合，如果存在该index到num的集合说明有效，直接返回；如果不存在说明这个number_to_index的映射是过期的无效映射，继续判定下一个。直到找到或队列为空。

### 代码 

#### 1.哈希表+set

```cpp
class NumberContainers {
public:
    NumberContainers() = default;

    void change(int index, int number) {

        auto it=index_to_number.find(index);

        if (it != index_to_number.end()) {
            number_to_index[it->second].erase(index);
        }

        index_to_number[index] = number;
        number_to_index[number].insert(index);

    }

    int find(int number) {

        auto it=number_to_index.find(number);
  if(it==number_to_index.end()||it->second.empty())

            return -1;

        return *it->second.begin();
    }
private:
    unordered_map<int, int> index_to_number;
    unordered_map<int, set<int>> number_to_index;
};
```

#### 2.哈希表+懒删除堆

```cpp
class NumberContainers {
    unordered_map<int, int> index_to_number;
    unordered_map<int, priority_queue<int, vector<int>, greater<int>>> number_to_indices;

public:
    void change(int index, int number) {
        index_to_number[index] = number;
        number_to_indices[number].push(index);
    }

    int find(int number) {
        auto& indices = number_to_indices[number];
        while (!indices.empty() && index_to_number[indices.top()] != number) {
            indices.pop();
        }
        return indices.empty() ? -1 : indices.top();
    }
};
```

## 9.18 3408.设计任务管理器(中等)

### 题目描述

难度：中等（1807）
>一个任务管理器系统可以让用户管理他们的任务，每个任务有一个优先级。这个系统需要高效地处理添加、修改、执行和删除任务的操作。
请你设计一个 `TaskManager` 类：
`TaskManager(vector<vector<int>>& tasks) `初始化任务管理器，初始化的数组格式为 `[userId, taskId, priority]` ，表示给 userId 添加一个优先级为 `priority` 的任务 `taskId` 。
`void add(int userId, int taskId, int priority)` 表示给用户 `userId` 添加一个优先级为 `priority` 的任务 `taskId` ，输入 **保证** taskId 不在系统中。
`void edit(int taskId, int newPriority) `更新已经存在的任务 `taskId` 的优先级为 newPriority 。输入 保证 `taskId` 存在于系统中。
`void rmv(int taskId)` 从系统中删除任务 `taskId` 。输入 **保证** `taskId` 存在于系统中。
`int execTop() `执行所有用户的任务中优先级 最高 的任务，如果有多个任务优先级相同且都为 最高 ，执行 `taskId` 最大的一个任务。执行完任务后，taskId 从系统中 **删除** 。同时请你返回这个任务所属的用户 `userId` 。如果不存在任何任务，返回 `-1` 。
**注意** ，一个用户可能被安排多个任务。

### 思路解析

思路和昨天的差不多，依旧**哈希表+懒删除堆**

使用`priority_queue<pair<Priority,Task_id>> pq`存储优先级和任务id,默认排序满足题目要求不需要自定义比较器
并存储映射`unordered_map<Task_id,pair<Priority,User_id>> ts;`

1. init:直接插入即可
2. add: 和init一样(输入保证taskId不在系统中)
3. edit: pq添加pair对象，ts修改映射。
4. rmv:只需要删除ts里的即可
5. execTop: 找pq里的priority里的最大值(top),然后根据taskId去看task最应的任务优先级是不是top里的优先级，如果不一样说明这个Top是被删除过的无效数据，继续看下一个，直到找到相同的或者pq为空。

### 代码

```cpp
class TaskManager {

    using Task_id=int;
    using User_id=int;
    using Priority=int;

public:
    TaskManager(vector<vector<int>>& tasks) {
        for (auto& task : tasks) {
            pq.emplace(task[2], task[1]);
            ts[task[1]]=make_pair(task[2], task[0]);
        }
    }

    void add(int userId, int taskId, int priority) {
        pq.emplace(priority, taskId);
        ts[taskId]=make_pair(priority, userId);
    }

    void edit(int taskId, int newPriority) {
        //输入保证在系统
        ts[taskId].first = newPriority;
        pq.emplace(newPriority, taskId);
    }

    void rmv(int taskId) {
        ts.erase(taskId);
    }

    int execTop() {
        while (!pq.empty()) {
            auto top = pq.top();
            pq.pop();
            if (ts.find(top.second) != ts.end()
                &&top.first==ts[top.second].first) {
                User_id userId = ts[top.second].second;
                ts.erase(top.second);
                return userId;
            }
        }
        return -1;
    }
private:
    unordered_map<Task_id,pair<Priority,User_id>> ts;
    priority_queue<pair<Priority,Task_id>> pq;

};
```

## 9.19 3484.设计电子表格（中等）

### 题目描述

难度：中等（1524）
>电子表格是一个网格，它有 `26` 列（从 'A' 到 'Z'）和指定数量的 `rows`。每个单元格可以存储一个 `0` 到 `105` 之间的整数值。
请你实现一个 `Spreadsheet` 类：
`Spreadsheet(int rows) `初始化一个具有 26 列（从 'A' 到 'Z'）和指定行数的电子表格。所有单元格最初的值都为 0 。
`void setCell(String cell, int value) `设置指定单元格的值。单元格引用以 "AX" 的格式提供（例如，"A1"，"B10"），其中字母表示列（从 'A' 到 'Z'），数字表示从 1 开始的行号。
`void resetCell(String cell)`重置指定单元格的值为 0 。
`int getValue(String formula)`计算一个公式的值，格式为 "=X+Y"，其中 X 和 Y 要么 是单元格引用，要么非负整数，返回计算的和。
注意： 如果 `getValue` 引用一个未通过 setCell 明确设置的单元格，则该单元格的值默认为 0 。

提示：
>1 <= rows <= 103
0 <= value <= 105
公式保证采用 "=X+Y" 格式，其中 X 和 Y 要么是有效的单元格引用，要么是小于等于 105 的 非负 整数。
每个单元格引用由一个大写字母 'A' 到 'Z' 和一个介于 1 和 rows 之间的行号组成。
总共 最多会对 setCell、resetCell 和 getValue 调用 104 次。

### 思路解析

很简单的模拟+字符串处理，直接用vector<vector<int>>模拟表格就可以
也可以用哈希表直接处理（减少了字符串处理）

### 代码

字符串法：

```cpp
class Spreadsheet {
public:
    Spreadsheet(int rows) {
        for (int i=0;i<rows;++i) {
            cells.emplace_back(26,0);
        }
    }

    void setCell(string cell, int value) {
        pair<int,int>pos=get_pos(cell);
        cells[pos.first][pos.second]=value;
    }

    void resetCell(string cell) {
        setCell(cell,0);
    }

    int getValue(string formula) {
        int add_pos=formula.find('+');
        string cell=formula.substr(1,add_pos-1);
        string cell2=formula.substr(add_pos+1);
        int num1,num2;
        if (isalpha(cell[0])) {
            pair<int,int>pos1=get_pos(cell);
            num1=cells[pos1.first][pos1.second];
        }else num1=stoi(cell);
        if (isalpha(cell2[0])) {
            pair<int,int>pos2=get_pos(cell2);
            num2=cells[pos2.first][pos2.second];
        }else num2=stoi(cell2);

        return num1+num2;
    }
private:
    vector<vector<int>> cells;
    pair<int,int> get_pos(string& cell) {
        int column=cell[0]-'A';
        int row=stoi(cell.substr(1))-1;
        return {row,column};
    }
};
```

哈希表：

```cpp
class Spreadsheet {
public:
    Spreadsheet(int rows) {}

    void setCell(string cell, int value) {
        cells[cell]=value;
    }

    void resetCell(string cell) {
        cells[cell]=0;
    }

    int getValue(string formula) {
        int add_pos=formula.find('+');
        string cell=formula.substr(1,add_pos-1);
        string cell2=formula.substr(add_pos+1);
        int num1,num2;
        if (isalpha(cell[0])) {
            num1=cells[cell];
        }else num1=stoi(cell);
        if (isalpha(cell2[0])) {
            num2=cells[cell2];
        }else num2=stoi(cell2);

        return num1+num2;
    }
private:
    map<string,int> cells;
};
```

## 9.20 3508.设计路由器（中等）

### 题目描述

难度：中等
>请你设计一个数据结构来高效管理网络路由器中的数据包。每个数据包包含以下属性：
`source`：生成该数据包的机器的唯一标识符。
`destination`：目标机器的唯一标识符。
`timestamp`：该数据包到达路由器的时间戳。
实现 Router 类：
`Router(int memoryLimit)`：初始化路由器对象，并设置固定的内存限制。
memoryLimit 是路由器在任意时间点可以存储的 最大 数据包数量。
如果添加一个新数据包会超过这个限制，则必须移除 最旧的 数据包以腾出空间。
`bool addPacket(int source, int destination, int timestamp)`：将具有给定属性的数据包添加到路由器。
如果路由器中已经存在一个具有相同 source、destination 和 timestamp 的数据包，则视为重复数据包。
如果数据包成功添加（即不是重复数据包），返回 true；否则返回 false。
`int[] forwardPacket()`：以 FIFO（先进先出）顺序转发下一个数据包。
从存储中移除该数据包。
以数组 [source, destination, timestamp] 的形式返回该数据包。
如果没有数据包可以转发，则返回空数组。
`int getCount(int destination, int startTime, int endTime)`：
返回当前存储在路由器中（即尚未转发）的，且目标地址为指定 destination 且时间戳在范围 [startTime, endTime]（包括两端）内的数据包数量。
注意：对于 addPacket 的查询会按照 timestamp 的递增顺序进行。

提示：
>2 <= memoryLimit <= 105
1 <= source, destination <= 2 * 105
1 <= timestamp <= 109
1 <= startTime <= endTime <= 109
addPacket、forwardPacket 和 getCount 方法的总调用次数最多为 105。
对于 addPacket 的查询，timestamp 按递增顺序给出。

### 思路解析

使用`set<tuple<int,int,int>>s`存储信息方便查找是否存在，set可以省略手写哈希类;
使用queue<tuple<int,int,int>>q存储消息队列;
使用map<int,pair<vector<int>,int>>des_to_time存储destision到时间的映射,最后的int表示出队指针;

1. addPacket：先看set里有没有，在看满没满，满了先出队再插入，直接调用forwardPacket出队一个(对于 addPacket 的查询会按照 timestamp 的递增顺序进行,入队顺序即时间顺序)，然后插入
2. forwardPacker:set和queue出队，des_to_time的指针后移一位来模拟出队（减少用时，erase begin需要O(n)慢）
3. 根据des_to_time二分查找就可以了

### 代码

```cpp
class Router {
public:
    Router(int memoryLimit):s(),memoryLimit(memoryLimit) {
    }

    bool addPacket(int source, int destination, int timestamp) {
        tuple t=make_tuple(source,destination,timestamp);

        if (s.find(t)!=s.end())
            return false;

        if (q.size()>=memoryLimit) {
            forwardPacket();
        }

        s.insert(t);
        q.push(t);
        des_to_time[destination].first.push_back(timestamp);

        return true;
    }

    vector<int> forwardPacket() {
        vector<int>res;
        if (!q.empty()) {
            auto [source,destination,timestamp]=q.front();
            q.pop();
            s.erase({source,destination,timestamp});
            //模拟出队
            des_to_time[destination].second++;
            return {source,destination,timestamp};
        }
        return {};
    }

    int getCount(int destination, int startTime, int endTime) {
        auto& [timestamps, head] = des_to_time[destination];
        auto left=lower_bound(timestamps.begin()+head,timestamps.end(),startTime);
        auto right=upper_bound(timestamps.begin()+head,timestamps.end(),endTime);
        return right-left;
    }
    set<tuple<int,int,int>>s;
    queue<tuple<int,int,int>>q;
    map<int,pair<vector<int>,int>>des_to_time;
    int memoryLimit;
};
```

## 1912.设计电影租借系统（困难）

### 题目描述

难度：困难（2182）
>你有一个电影租借公司和 n 个电影商店。你想要实现一个电影租借系统，它支持查询、预订和返还电影的操作。同时系统还能生成一份当前被借出电影的报告。
所有电影用二维整数数组 `entries` 表示，其中 entries[i] = [shopi, moviei, pricei] 表示商店 shopi 有一份电影 moviei 的拷贝，租借价格为 pricei 。每个商店有 至多一份 编号为 moviei 的电影拷贝。
系统需要支持以下操作：
`Search`：找到拥有指定电影且 未借出 的商店中 最便宜的 5 个 。商店需要按照 价格 升序排序，如果价格相同，则 shopi 较小 的商店排在前面。如果查询结果少于 5 个商店，则将它们全部返回。如果查询结果没有任何商店，则返回空列表。
`Rent`：从指定商店借出指定电影，题目保证指定电影在指定商店 未借出 。
Drop：在指定商店返还 之前已借出 的指定电影。
`Report`：返回 最便宜的 5 部已借出电影 （可能有重复的电影 ID），将结果用二维列表 res 返回，其中 res[j] = [shopj, moviej] 表示第 j 便宜的已借出电影是从商店 shopj 借出的电影 moviej 。res 中的电影需要按 价格 升序排序；如果价格相同，则 shopj 较小 的排在前面；如果仍然相同，则 moviej 较小 的排在前面。如果当前借出的电影小于 5 部，则将它们全部返回。如果当前没有借出电影，则返回一个空的列表。
请你实现 MovieRentingSystem 类：
`MovieRentingSystem(int n, int[][] entries) `将 MovieRentingSystem 对象用 n 个商店和 entries 表示的电影列表初始化。
List<Integer> search(int movie) 如上所述，返回 未借出 指定 movie 的商店列表。
`void rent(int shop, int movie)` 从指定商店 shop 借出指定电影 movie 。
`void drop(int shop, int movie) `在指定商店 shop 返还之前借出的电影 movie 。
`List<List<Integer>> report() `如上所述，返回最便宜的 已借出 电影列表。
注意：测试数据保证 rent 操作中指定商店拥有 未借出 的指定电影，且 drop 操作指定的商店 之前已借出 指定电影。

提示：
>1 <= n <= 3 * 105
1 <= entries.length <= 105
0 <= shopi < n
1 <= moviei, pricei <= 104
每个商店 至多 有一份电影 moviei 的拷贝。
search，rent，drop 和 report 的调用 总共 不超过 105 次。

### 思路解析

使用map<pair<int,int>,int>shop_movie_to_price存储shop,movie到price的映射（因为rent和drop都是根据这个），map可以避免手写哈希；
使用set<tuple<int,int,int>>rented_movies存储已经租出的电影信息，三个int是price,shop,movie(根据Report函数要求);
unordered_map<int, set<pair<int, int>>> unrented_movie_to_price_shop存储为了被租出去的movie

1. init：给map和unordered_map添加数据
2. Search:从unrented_movie_to_price_shop直接找
3. Rent:从shop_movie_to_price找到电影，存入rented_movies,unrented的数据也删掉
4. Drop:Rent的逆操作，思路一样
5. Report:输出rented_shop的前五条数据就可以了

### 代码

```cpp
class MovieRentingSystem {
public:
    MovieRentingSystem(int n, vector<vector<int>>& entries){
        for (auto &e: entries) {
            int shop = e[0], movie = e[1], price = e[2];
            shop_movie_to_price[{shop, movie}] = price;
            unrented_movie_to_price_shop[movie].insert( {price, shop});
        }
    }

    vector<int> search(int movie) {
        auto it=unrented_movie_to_price_shop.find(movie);
        if (it==unrented_movie_to_price_shop.end())
            return {};
        vector<int>result;
        for (auto &t:it->second) {
            result.push_back(t.second);
            if (result.size()>=5)
                break;
        }
        return result;
    }

    void rent(int shop, int movie) {
        int price=shop_movie_to_price[{shop,movie}];
        unrented_movie_to_price_shop[movie].erase({price,shop});
        rented_movies.insert({price,shop,movie});
    }

    void drop(int shop, int movie) {
        int price=shop_movie_to_price[{shop,movie}];
        rented_movies.erase({price,shop,movie});
        unrented_movie_to_price_shop[movie].insert({price,shop});
    }

    vector<vector<int>> report() {
        vector<vector<int>>result;
        for (auto &it:rented_movies) {
            result.push_back({get<1>(it),get<2>(it)});
            if (result.size()>=5)
                break;
        }
        return result;
    }
private:
    map<pair<int,int>,int>shop_movie_to_price;
    set<tuple<int,int,int>>rented_movies;
    unordered_map<int, set<pair<int, int>>> unrented_movie_to_price_shop;
};
```
