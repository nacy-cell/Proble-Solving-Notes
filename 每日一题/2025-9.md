# 每日一题-2025年9月

## 9.13 3541.找到频率最高的元音和辅音(简单)

### 题目描述

难度：简单 1239

>给你一个由小写英文字母（'a' 到 'z'）组成的字符串 s。你的任务是找出出现频率**最高**的元音（'a'、'e'、'i'、'o'、'u' 中的一个）和出现频率**最高**的辅音（除元音以外的所有字母），并返回这两个频率之和。
**注意**：如果有多个元音或辅音具有相同的最高频率，可以任选其中一个。如果字符串中没有元音或没有辅音，则其频率视为 0。
一个字母 x 的**频率**是它在字符串中出现的次数。

提示:
>1 <= s.length <= 100
s 只包含小写英文字母

### 思路解析

一次遍历，统计每一个字母的出现次数
分开统计元音和辅音出现次数最高的字母，求和即可

### 代码

```cpp
int maxFreqSum(std::string s) {
        int times[27] = {0};
        for (char c : s) {
            times[c - 'a']++;
        }
        int ans1 = 0,ans2=0;
        for (int i = 0; i < 27; i++) {
            if (i==0 || i==4 || i==8 || i==14 || i==20) {
                ans1=std::max(ans1,times[i]);
            } else {
                ans2=std::max(ans2,times[i]);
            }
        }
        return ans1+ans2;
    }
```

## 9.14 966.元音拼写检查器（中等）

### 题目描述

难度：中等（1795）

>在给定单词列表 wordlist 的情况下，我们希望实现一个拼写检查器，将查询单词转换为正确的单词。
对于给定的查询单词 query，拼写检查器将会处理两类拼写错误：
**大小写**：如果查询匹配单词列表中的某个单词（**不区分大小写**），则返回的正确单词与单词列表中的大小写相同。
例如：```wordlist = ["yellow"], query = "YellOw": correct = "yellow"```
例如：```wordlist = ["Yellow"], query = "yellow": correct = "Yellow"```
例如：```wordlist = ["yellow"], query = "yellow": correct = "yellow"```
**元音错误**：如果在将查询单词中的元音 ('a', 'e', 'i', 'o', 'u')  分别替换为任何元音后，能与单词列表中的单词匹配（**不区分大小写**），则返回的正确单词与单词列表中的匹配项大小写相同。
例如：```wordlist = ["YellOw"], query = "yollow": correct = "YellOw"```
例如：```wordlist = ["YellOw"], query = "yeellow": correct = ""``` （无匹配项）
例如：```wordlist = ["YellOw"], query = "yllw": correct = ""``` （无匹配项）
此外，拼写检查器还按照以下优先级规则操作：
1.当查询完全匹配单词列表中的某个单词（**区分大小写**）时，应返回相同的单词。
2.当查询匹配到大小写问题的单词时，您应该返回单词列表中的第一个这样的匹配项。
3.当查询匹配到元音错误的单词时，您应该返回单词列表中的第一个这样的匹配项。
4.如果该查询在单词列表中没有匹配项，则应返回空字符串。
给出一些查询 queries，返回一个单词列表 answer，其中 answer[i] 是由查询 query = queries[i] 得到的正确单词。

提示：
>1 <= wordlist.length, queries.length <= 5000
1 <= wordlist[i].length, queries[i].length <= 7
wordlist[i] 和 queries[i] 只包含英文字母

### 思路解析

1. 先将wordlist里的单词存入set中（方便查询）
2. 将wordlist中单词转换成小写，存入lower_map中(先检查是否存在，确保只存入第一个)，进行lower_case到原单词的映射。
3. 将lower_case单词中所有的元音字母替换成'a',去除元音字母的差异,并存入vowels_map,实现vowels_ignored_case到原单词的映射
4. 最后遍历querys集合进行查询，查询每一个单词对应的原单词即可

### 代码

```cpp
class Solution_25_9_14 {
public:

    string to_lower(string s)const {
        for (char&c:s) {
            c=tolower(c);
        }
        return s;
    }

    string replace(string s) {
        for (char&c:s) {
            if (c=='e'||c=='i'||c=='o'||c=='u')
                c='a';
        }
        return s;
    }

    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {
        unordered_set wordset(wordlist.begin(), wordlist.end());
        unordered_map<string,string>lower_map;
        unordered_map<string,string>vowels_map;
        for (string& word:wordlist) {
            //大小写匹配
            string lower = to_lower(word);
            if (!lower_map.count(lower)) {
                lower_map[lower] = word;
            }
            //原因匹配
            string vowels=replace(lower);
            if (!vowels_map.count(vowels)) {
                vowels_map[vowels] = word;
            }
        }


        vector<string> result;
        for (string& word:queries) {
            string lower = to_lower(word);
            string vowels=replace(lower);

            if (wordset.count(word))
                result.push_back(word);
            else if (lower_map.count(lower))
                result.push_back(lower_map[lower]);
            else if (vowels_map.count(vowels))
                result.push_back(vowels_map[vowels]);
            else result.emplace_back("");
        }

        return result;
    }
};
```

## 9.15 1935.可以输入的最大单词数(简单)

### 题目描述

难度： 简单（1227）
>键盘出现了一些故障，有些字母键无法正常工作。而键盘上所有其他键都能够正常工作。
给你一个由若干单词组成的字符串 `text` ，单词间由单个空格组成（不含前导和尾随空格）；另有一个字符串 `brokenLetters` ，由所有已损坏的不同字母键组成，返回你可以使用此键盘完全输入的 `text`中单词的数目。

提示：
>1 <= text.length <= 104
0 <= brokenLetters.length <= 26
text 由若干用单个空格分隔的单词组成，且不含任何前导和尾随空格
每个单词仅由小写英文字母组成
brokenLetters 由 互不相同 的小写英文字母组成

### 思路解析

1. 首先把故障键位存入set中，方便查询
2. 使用flag标志位标记当前单词是否存在故障位
3. text后面加一个" "方便处理
4. 遍历text所有字母，检查该字母是否是故障字母，如果是把flag置为false;当遇到" "说明一个单词扫描结束:如果flag=true,++ans;否则重新把flag置于true进行下一个单词的扫描
5. 最后返回ans即可

### 代码

```cpp
int canBeTypedWords(string text, string brokenLetters) {

        unordered_set<char> unenble_set;
        for (char letter : brokenLetters) {
            unenble_set.insert(letter);
        }

        int ans=0;
        text=text+" ";
        bool flag=true;
        
        for (char letter : text) {
            if (letter==' ') {
                if (flag) ++ans;
                flag=true;
            }
            else if (unenble_set.find(letter)!=unenble_set.end()) {
                flag=false;
            }
        }
        return ans;
    }
```

## 9.16 2197.替换数组中的非互质数

### 题目描述

难度：困难（2057） 实际难度简单题
>给你一个整数数组 nums 。请你对数组执行下述操作：
从 nums 中找出 任意 两个 **相邻** 的 **非互质** 数。
如果不存在这样的数，终止 这一过程。
否则，删除这两个数，并 **替换** 为它们的 **最小公倍数**（Least Common Multiple，LCM）。
只要还能找出两个相邻的非互质数就继续 重复 这一过程。
返回修改后得到的 最终 数组。可以证明的是，以 **任意** 顺序替换相邻的非互质数都可以得到相同的结果。
生成的测试用例可以保证最终数组中的值 小于或者等于 108 。
两个数字 x 和 y 满足 **非互质数** 的条件是：GCD(x, y) > 1 ，其中 GCD(x, y) 是 x 和 y 的 最大公约数 。

提示：
>1 <= nums.length <= 105
1 <= nums[i] <= 105
生成的测试用例可以保证最终数组中的值 小于或者等于 108 。

### 思路解析

最大公因数可以通过欧几里德算法或gcd(a,b)(cpp17 numeric)函数获得
a,b的最小公倍数是a*b/gcd(a,b)先除后乘避免数据溢出
实际数据结构是栈，为了方便使用vector函数

1. 遍历数组，如果当前数字与栈顶数字不互质，计算最小公倍数
2. 将最小公倍数视为当前数字，继续与栈顶比较，直到互质或栈空，当前数字入栈。即可维护相邻数字互质。
3. 返回得到的栈即可

### 代码

```cpp
    int get_gcd(int a, int b) {
        if (b == 0)
            return a;
        return get_gcd(b, a % b);
    }

    vector<int> replaceNonCoprimes(vector<int>& nums) {
        vector<int> st;
        for (auto num : nums) {
            while (!st.empty()) {
                int gcd = get_gcd(st.back(), num);
                if (gcd == 1) {
                    break;
                }
                num = num/gcd*st.back();
                st.pop_back();
            }
            st.push_back(num);
        }
        return st;
    }
```

## 9.17 

### 题目描述

难度： 中等(1540)

>设计一个数字容器系统，可以实现以下功能：
在系统中给定下标处 **插入** 或者 **替换** 一个数字。
**返回** 系统中给定数字的最小下标。
请你实现一个 `NumberContainers` 类：
`NumberContainers()` 初始化数字容器系统。
`void change(int index, int number)` 在下标 `index` 处填入 number 。如果该下标 index 处已经有数字了，那么用 `number` 替换该数字。
`int find(int number)` 返回给定数字 `number` 在系统中的最小下标。如果系统中没有 `number` ，那么返回`-1` 。

提示：
>1 <= index, number <= 10^9^
调用 change 和 find 的 **总次数** 不超过 10^5^ 次。

### 思路解析

#### 1.哈希表+set

使用
`unordered_map<int, int> index_to_number;` `unordered_map<int, set<int>> number_to_index`来存储索引到数字和数字到索引的映射

1. change函数：
   先去删除index对应的原`number`的索引映射集对index的映射
   然后添加index->number的映射，之后把index添加到number的映射集中，set会自动排序确保头部是`find`要求的最小下标
2. find函数：直接从`number_to_index`查找即可（注意判空）

#### 2.哈希表+懒删除堆

使用`unordered_map<int, int> index_to_number` `unordered_map<int, priority_queue<int, vector<int>, greater<int>>> number_to_indices`来存储索引到数字和数字到索引的映射
greater确保从小到达排序

1. change函数： 直接插入双映射即可（重合的index_to_numer会自动替换）
2. find函数，首先获取number对应的映射集合。从小到大遍历nuber的映射集合，如果存在该index到num的集合说明有效，直接返回；如果不存在说明这个number_to_index的映射是过期的无效映射，继续判定下一个。直到找到或队列为空。

### 代码 

#### 1.哈希表+set

```cpp
class NumberContainers {
public:
    NumberContainers() = default;

    void change(int index, int number) {

        auto it=index_to_number.find(index);

        if (it != index_to_number.end()) {
            number_to_index[it->second].erase(index);
        }

        index_to_number[index] = number;
        number_to_index[number].insert(index);

    }

    int find(int number) {

        auto it=number_to_index.find(number);
  if(it==number_to_index.end()||it->second.empty())

            return -1;

        return *it->second.begin();
    }
private:
    unordered_map<int, int> index_to_number;
    unordered_map<int, set<int>> number_to_index;
};
```

#### 2.哈希表+懒删除堆

```cpp
class NumberContainers {
    unordered_map<int, int> index_to_number;
    unordered_map<int, priority_queue<int, vector<int>, greater<int>>> number_to_indices;

public:
    void change(int index, int number) {
        index_to_number[index] = number;
        number_to_indices[number].push(index);
    }

    int find(int number) {
        auto& indices = number_to_indices[number];
        while (!indices.empty() && index_to_number[indices.top()] != number) {
            indices.pop();
        }
        return indices.empty() ? -1 : indices.top();
    }
};
```
